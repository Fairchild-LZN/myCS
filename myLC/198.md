# 198 打家劫舍

## 不爱睡觉的大猪

```C++
/*
房子从0到n-1编号

f[0][i]: 怼前i个房子进行偷窃，且第i个房子不偷，能获得的最大受益
f[1][i]: 怼前i个房子进行偷窃，且第i个房子偷，能获得的最大受益

答案：max(f[0][n-1], f[1][n-1])

转移：
f[0][i] = max(f[0][i-1], f[1][i-1])
f[1][i] = f[0][i-1] + a[i]

优化空间：第i个房子的状态只和第i-1个房子的状态有关，滚动数组
x[0], x[1]表示上一个房子不偷和偷的状态
y[0], y[1]表示当前房子不偷和偷的状态

*/

class Solution{
    public:
    int rob(vector<int>& a){
        vector<int> x(2), y(2);

        // 初始化第一个房子的状态
        x[0] = 0, x[1] = a[0];

        for(int i = 1; i < a.size(); i++){
            y[0] = max(x[0], x[1]);
            y[1] = x[0] + a[i];
            swap(x, y);
        }

        return max(x[0], x[1]);
    }
};
```
