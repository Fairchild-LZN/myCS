# 1. 模板

- 主要针对C++的**泛型编程**和**STL**技术做详细讲解，探讨C++更深层的应用

## 1.1 模板的概念

- 模板就是建立通用的模具，大大提高复用性
- 模板不可以直接使用，它只是一个框架
- 模板是通用的，不是万能的

## 1.2 函数模板

- C++另一种编程思想称为 **泛型编程** ，主要利用的技术就是模板
- C++提供给两种模板机制： **函数模板** 和 **类模板**

### 1.2.1 函数模板语法

- 函数模板作用：建立一个通用函数，其函数返回值类型和形参类型可以不具体指定，用一个虚拟的类型来代表
- 函数模板利用关键字template
- 使用函数模板有两种方式：自动类型推导，显示指定类型
- 模板的目的是为了提高复用性，将类型参数化

```C++
// 模板语法
template<typename T>
// 函数声明或定义
void mySwap(T &a, T &b){
    T temp =a;
    a = b;
    b = temp;
}

//1.自动类型推到
mySwap(a, b);
//2.显示指定类型
mySwap<int>(a, b);

```

#### 解释

- template  声明创建模板
- typename  表明其后面的符号是一种数据类型，可以用class代替

### 1.2.2 函数模板注意事项

- 自动类型推导，必须推导出一致的数据类型T，才可以使用
- 模板必须要确定出T的数据类型，才可以使用

### 1.2.3 函数模板案例

```C++
#include<iostream>
using namespace std;

template<typename T>
void mySwap(T &a, T &b){
    T temp =a;
    a = b;
    b = temp;
}

template<typename T>
void printArray(T arr[], int len){
    for (int i = 0; i < len; i++){
        cout << arr[i] << " ";
    }
    cout << endl;
}

template<typename T>
void mySort(T arr[], int len){
    for (int i = 0; i < len; i++){
        int max = i;
        for (int j = i + 1; j < len; j++){
            if(arr[max] < arr[j]){
                max = j;
            }
        }
        if(max != i){
            mySwap(arr[max], arr[i]);
        }
    }
}

void test1(){
    char charArr[] = "babcfe";
    int num = sizeof(charArr) / sizeof(char);
    mySort(charArr, num);
    printArray(charArr, num);
}

void test2(){
    int intArr[] = {7, 5, 1, 3, 2, 4};
    int num = sizeof(intArr) / sizeof(int);
    mySort(intArr, num);
    printArray(intArr, num);
}

int main(){
    test1();
    test2();

    system("Pause")
    return 0;
}
```

### 1.2.4 普通函数与函数模板的区别

1. 普通函数调用时可以发生自动类型转换（隐式类型转换）
2. 函数模板，如果利用自动类型推导，不可以发生隐式类型转换
3. 函数模板，如果利用显示指定类型的方式，可以发生隐式类型转换
4. 建议使用显示指定类型的方式，调用函数模板，因为自己可以确定通用类型T

### 1.2.5 普通函数与函数模板的调用规则

#### 规则

1. 如果函数模板和普通函数都可以实现，优先调用普通函数
2. 可以通过空模板参数列表来强制调用函数模板   `myPrint<>(a, b);`
3. 函数模板也可以发生重载
4. 如果函数模板可以产生更好的匹配，优先调用函数模板

### 1.2.6 模板的局限性

- 模板的通用性并不是万能的（对于数组和自定义的数据类型，无法正常运行）
- 利用具体化的模板，可以解决自定义类型的通用化
- 学习模板并不是为了写模板，而是在STL能够运用系统提供的模板

## 1.3 类模板

### 1.3.1 类模板语法

- 建立一个通用类，类中的成员，数据类型可以不具体制定，用一个虚拟的类型来代表
- 类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板

### 1.3.2 类模板与函数模板区别

1. 类模板没有自动类型推导的使用方式
2. 类模板在模板参数列表中可以有默认参数

- 类模板使用只能用显示指定类型方式
- 类模板中的模板参数列表可以有默认参数

### 1.3.3 类模板中成员函数创建时机

- 普通类中的成员函数一开始就创建
- 类模板中的成员函数并不是一开始就创建，在调用时才去创建

### 1.3.4 类模板对象做函数参数

- 类模板实例化出的对象，向函数传参的方式

#### 三种传入方式

1. 指定传入的类型       --- 直接显示对象的数据类型
2. 参数模板化           --- 将对象中的参数变为模板进行传递
3. 整个类模板化         --- 将这个对象类型模板化进行传递

- 通过类模板创建的对象，可以有三种方式向函数中进行传参
- 使用比较广泛的是第一种：指定传入的类型

### 1.3.5 类模板与继承

- 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型
- 如果不指定，编译器无法给子类分配内存
- 如果想灵活指定出父类中T的类型，子类也需要为类模板
- 如果父类是类模板，子类需要指定出父类中T的数据类型

### 1.3.6 类模板成员函数类外实现

```C++
// 构造函数，类外实现
template<typename T1, typename T2>
Person<T1, T2>::Person(T1 name, T2 age){
    this->mName = name;
    this->mAge = age;
}
```

- 类模板中成员函数类外实现时，需要加上模板参数列表

### 1.3.7 类模板分文件编写

#### 问题

- 类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到

#### 解决方法

1. 直接包含.cpp源文件
2. 将声明和实现写到同一个文件中，并更改后缀名为.hpp，.hpp是约定的名称，并不是强制的

### 1.3.8 类模板与友元

- 全局函数类内实现 - 直接在类内声明友元即可
- 全局函数类外实现 - 需要提前让编译器知道全局函数的存在
- 建议全局函数做类内实现，用法简单，而且编译器可以直接识别

### 1.3.9 类模板案例
