# 4.类和对象

- C++面向对象的三大特性：***封装、继承、多态***
- C++认为万事万物皆为对象，对象拥有自己的属性和行为

## 4.1 封装

### 4.1.1 封装的意义

- 封装是C++面向对象三大特性之一
- 在设计类的时候，属性和行为写在一起，表现事物
- 语法： class 类名 { 访问权限： 属性/行为};
- 类中的属性和行为，统一称为 *成员*

#### 意义1

1. 将属性和行为作为一个整体，表现生活中的事物
2. 将属性和行为加以权限控制

#### 意义2

- 类在设计时，可以把属性和行为放在不同的权限下，加以控制

1. 公共权限 public      成员 类内可以访问，类外可以访问
2. 保护权限 protected   成员 类内可以访问，类外不可以访问   儿子可以访问父亲的保护内容
3. 私有权限 private     成员 类内可以访问，类外不可以访问   儿子不可以访问父亲的私有内容

### 4.1.2 struct和class的区别

#### 在C++中struct和class唯一的区别在于 *默认的访问权限不同*

- struct    默认权限为公共
- class     默认权限为私有

### 4.1.3 成员属性设置为私有

- 优点1：将所有成员属性设置为私有，可以自己控制读写权限
- 优点2：对于写权限，我们可以检测数据的有效性

```C++
class Person{
    public:
    void setAge(int age){
        myAge = age;
    }
    int getAge(){
        myAge = 18;
        return myAge
    }
    private:
    int myAge;
};
```

## 4.2 对象的初始化和清理

- 生活中我们买的电子产品都基本会有*出厂设置*，在某一天我们不用的时候也会删除一些自己信息数据保证安全
- C++中的面向对象来源于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置

### 4.2.1 构造函数和析构函数

- 对象的 *初始化和清理* 也是两个非常重要的安全问题
- 一个对象或者变量没有初始状态，对其使用后果是未知的
- 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题
- C++使用了**构造函数**和**析构函数**解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作
- 如果我们不提供构造和析构，编译器会自己提供，**编译器提供的构造函数和析构函数都是空实现**
- 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用
- 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作

#### 构造函数语法：类名(){}

1. 构造函数，没有返回值，也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时候会自动调用构造，无需手动调用，而且只会调用一次

#### 析构函数语法：~类名(){}

1. 析构函数，没有返回值，也不写void
2. 函数名称与类名相同，在名称前加上符号~
3. 析构函数不可以有参数，不可以发生重载
4. 对象在销毁前，会自动调用析构函数，而且只会调用一次

### 4.2.2 构造函数的分类及调用

#### 两种分类方式

- 按参数分为：有参构造和无参构造
- 按类型分为：普通构造和拷贝构造

#### 三种调用方式

- 括号法
- 显示法
- 隐式调用法

```c++
class Person{
    public:
    Person(){
        cout << "Person的无参构造函数调用" << endl;
    }
    Person(int a){
        cout << "Person的有参构造函数调用" << endl;
    }
    Person(const Person &p){
        cout << "Person的拷贝构造函数调用" << endl;
        age = p.age;
    }
    ~Person(){
        cout << "Person的析构函数调用" << endl;
    }
    int age;
};

int main(){

    // 括号法
    Person p0(10);
    Person p1(p0);

    // 显示法
    Person p2 = Person(10);
    Person p3 = Person(p2);
    Person(10); 

    // 隐式转换法
    Person p4 = 10;
    Person p5 = p4
}
```

#### 注意事项

- 调用默认构造函数时，不要加()，因为会被编译器认为是一个函数的声明
- Person(10)单独写是匿名对象，特点：当前行执行结束后，系统会立即析构匿名对象
- 不要利用拷贝构造函数，初始化匿名对象，编译器会认为是对象的声明

### 4.2.3 拷贝构造函数调用时机

#### C++中调用拷贝构造函数的三种情况

1. 使用一个已经创建完毕的对象来初始化一个新对象
2. 值传递的方式给函数参数传值
3. 值方式返回局部对象

### 4.2.4 构造函数调用规则

#### 默认情况下，c++编译器至少给一个类添加三个函数

1. 默认构造函数（无参，函数体为空）
2. 默认析构函数（无参，函数体为空）
3. 默认拷贝构造函数，对属性进行值拷贝

#### 构造函数调用规则如下

- 如果我们写了有参构造函数，编译器就不再提供默认构造函数，但是依然提供拷贝构造函数
- 如果我们写了拷贝构造函数，编译器就不再提供其他任何构造函数

### 4.2.5 深拷贝与浅拷贝（重点）

- 深浅拷贝是面试经典问题，也是常见的一个坑
- 深拷贝：在堆区重新申请空间，进行拷贝操作
- 浅拷贝：简单的赋值拷贝操作
- 浅拷贝带来的问题是堆区的内存会被重复释放
- 浅拷贝的问题要用深拷贝来解决

### 4.2.6 初始化列表

- **作用：C++提供了初始化列表语法，用来初始化属性**
- 语法：构造函数(): 属性1(值1), 属性2(值2) ... {}

```C++
class Person{
    public:
    Person(int a, int b, int c): myA(a), myB(b), myC(c){

    }
    int myA, myB, myC;
}
```

### 4.2.7 类对象作为类成员

- C++类中的成员可以是另一个类的对象，我们称该成员为对象成员
- 当其他类对象作为本类成员，构造时先构造其他类的对象，再构造自身；析构时先析构自身，再析构其他类的对象

### 4.2.8 静态成员

- 静态成员就是在成员变量和成员函数前加上关键字 *static*

#### 静态成员变量

- 所有对象共享同一份数据
- 在编译阶段分配内存
- 类内声明，类外初始化

#### 静态成员函数

- 所有对象共享同一个函数
- 静态成员函数只能访问静态成员变量

## 4.3 C++对象模型和this指针

### 4.3.1 成员变量和成员函数分开存储

- 在C++中，类内的成员变量和成员函数分开存储
- 只有非静态成员变量才属于类的对象
- 空对象占用的内存空间为 ***1***

### 4.3.2 this指针概念

- 每一个非静态成员函数只会诞生一份函数示例，也就是说多个同类型的对象会共用一块代码。那么这块代码是如何区分哪个对象是自己调用的呢？
- C++通过提供特殊的对象指针，this指针，解决上述问题，**this指针指向被调用的成员函数所属的对象**
- this指针是隐含在每一个非静态成员函数内的一种指针
- this指针不需要定义，直接使用即可

#### this指针的用途

- 当形参和成员变量同名时，可用this指针来区分
- 在类的非静态成员函数中返回对象本身，可以使用 **return *this** ，链式编程

### 4.3.3 空指针访问成员函数

- C++中空指针也是可以调用成员函数的，但是也需要注意没有用到this指针
- 如果用到this指针，需要加以判断保证代码的健壮性

```C++
if(this == NULL){
    return;
}
```

### 4.3.4 const修饰成员函数

- this指针的本质是指针常量，指针的指向是不可以修改的
- 在成员函数后面加const，修饰的是this指向，让指针指向的值也不可以修改

#### 常函数

- 成员函数后加const后我们称为这个函数为常函数
- 常函数内不可以修改成员属性
- 成员属性声明时加关键字 mutable 后，在常函数中依然可以修改

#### 常对象

- 声明对象前加const称为该对象为常对象
- 常对象只能调用常函数

## 4.4 友元

- 在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术
- 友元的目的是让一个函数或者类访问另一个类中私有成员
- 友元的关键字为：friend

### 4.4.1 全局函数做友元

- 在class中的public之前，写 friend 返回值类型 函数名()

### 4.4.2 类做友元

```C++
class Building{
    friend void myFriend();
    friend class Person;
    friend void goodFriend::visit();

    public:
    Building();
};

Building :: Building(){

}
```

### 4.4.3 成员函数做友元

## 4.5 运算符重载

- 概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型

### 4.5.1 加号运算符重载

- **作用：实现两个自定义数据类型相加的运算**

```C++
Person operator+(Person &p1, Person &p2){
    Person temp;
    temp.mA = p1.mA + p2.mA;
    temp.mB = p1.mB + p2.mB;
    return temp;
}
```

- 对于内置的数据类型的表达式的运算符是不可能改变的
- 不要滥用运算符重载

### 4.5.2 左移运算符重载

- **作用：可以输出自定义数据类型**

```C++
ostream & operator<<(ostream &ccout, Person &p){
    ccout << p.mA
    return ccout;
}
```

- 重载左移运算符配合友元可以实现输出自定义数据类型

### 4.5.3 递增运算符重载

- **作用：通过重载递增运算符，实现自己的整型数据**
- 前置递增返回引用，后置递增返回值

### 4.5.4 赋值运算符重载

- C++编译器会给每个类自动添加，赋值运算符 operator= 对属性进行值拷贝
- 如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题

### 4.5.5 关系运算符重载

- **作用：重载关系运算符，可以让两个自定义类型对象进行对比操作**

### 4.5.6 函数调用运算符重载

- 函数调用运算符 () 也可以重载
- 由于重载后使用的方式非常像函数，因此被称为**仿函数**
- 仿函数没有固定写法，非常灵活

## 4.6 继承

- 有些类与类之间存在特殊的关系，下级别的成员除了拥有上一级的共性，还有自己的特性。这个时候可以使用继承的技术，减少重复代码

### 4.6.1 继承的基本语法

